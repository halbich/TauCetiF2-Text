%!TEX root = ../../prace.tex



\section{Komponenty bloků}
\label{sec:komponents}

Nyní přistoupíme k~řešení problému rozšiřování funkcionality bloků. Z~analýzy v~části \ref{subsec:bloky} vyplývá, že některé bloky mají mj.~elektrickou komponentu, některé mají kyslíkovou komponentu a~jeden z~nich má obojí. Tradiční přístup \textit{OOP} nám nabízí použití rozhraní či dědičnosti. Práce s~rozhraním není v~\UEu{} nikterak jednoduchá, takže bychom rádi našli snazší cestu. Ačkoliv \CPP{} umožňuje vícenásobnou dědičnost, \UE{} ji kvůli svým kompilačním nástrojům nepovoluje. Navíc by bylo velmi těžké vymyslet takovou hierarchii dědičnosti bloků, abychom splnili požadavky pro všechny bloky a~přitom si zároveň neuzavřeli cestu pro implementaci nových bloků. 

Jednou z~dalších možností, jak problém sdílené funkcionality řešit, je systém \textit{komponent}, který nám \UE{} nabízí. Komponenta je programová část, která ovlivňuje chování vlastníka dané komponenty. Cílem je pak dosáhnout toho, že je možné za běhu hry jednu komponentu transparentně vyměnit za jinou (komponentu s~jinou implementací), a~vlastník komponenty se nemusí zajímat o~detaily implementace. Díky tomu je možné snadno rozšiřovat vlastnosti a~chování vlastníků dané komponenty.

Z předchozí analýzy vyplývá, že budeme potřebovat řešit následující problémy:

\begin{itemize}
	\item Práce s~kyslíkem
	\item Práce s~elektrickou sítí a~energií
	\item Interakce s~uživatelem
	\item Umístění bloku v~herním světě
\end{itemize}


Tyto problémy jsou ideální kandidáti na použití komponent. Pokud bychom se někdy v~budoucnu rozhodli upravit chování některé funkcionality či jej z~libovolného důvodu změnit, komponentový systém pro nás bude výhodou. Navíc ne všechny herní bloky umí (z hlediska herního designu) kupříkladu s~kyslíkem či elektřinou pracovat. Jak jsme již zmínili dříve,  s~použitím komponent to bude snadné -- bloky, které danou funkcionalitu mají umět, budou mít danou komponentu a~budou s~ní moci pracovat. Taktéž tím u~kyslíku a~energie získáme možnost přiřadit tyto komponenty hráčově postavě a~tím nebudeme duplikovat funkcionalitu.

\subsection{Komponenta kyslíku}

Cílem komponenty kyslíku by mělo být udržování informace o~aktuálním množství \uv{vlastněného} kyslíku a~dále pak převody mezi jednotlivými komponentami. V~rámci herního designu jsme se rozhodli, že kyslík bude ve hře vyráběn z~elektrické energie. Z~toho nám vyplývá, že kupříkladu blok s~elektrickou a~kyslíkovou komponentou musí mít možnost provádět převody zdrojů a~tedy bude moci měnit množství vlastněného kyslíku ve prospěch či neprospěch jiné kyslíkové komponenty (například té, kterou bude vlastnit blok \nameref{blocks:B10}). 



Obdobně jako u~bloků, kyslíková komponenta bude obsahovat reference na \textit{definiční} třídu a~\textit{instanční} třídu a~jejich chování bude vycházet z~principů chování definiční a~instanční třídy u~vlastností bloků. \textit{Definiční} třída bude definovat \textit{maximální objem drženého kyslíku} pro daný blok (a stejně jako u~výpočtu zdraví se pro danou instanci bloku použije algoritmus \ref{eq:alg}). Dále bude definovat \textit{maximální přenesený objem kyslíku za 1~herní sekundu}. Z~toho vyplývá, že budeme mít možnost řídit, jak dlouho bude probíhat přenos třeba z~bloku Plničky kyslíkových bomb do bloku Kyslíkové bomby, nebo z~bloku Kyslíkové bomby k~herní postavě hráče. Od této limitace přenosu si slibujeme, že hráčům přinese  věrohodnější herní zážitek. 

\subsection{Komponenta energie}

Komponenta energie by měla být v~mnohém velmi podobná Kyslíkové komponentě. Měla by udržovat informace o~\uv{vlastněné} energii a~taktéž by měla obsahovat reference na \textit{definiční} a~\textit{instanční} třídu. \textit{Definice} pro daný blok by měla obsahovat \textit{maximální objem} a~\textit{limit přenosu}. 

Navíc bychom chtěli, aby Energetická komponenta uměla pracovat s~\textit{elektrickou sítí}. Aby byla komponenta v~nějaké elektrické síti, musí se blok vlastnící tuto komponentu dotýkat jiného bloku s~elektrickou komponentou. Protože vycházíme z~reálného světa, tento dotyk vlastně simuluje vodivý spoj. Proto musíme pro každý blok s~touto komponentou umět zadefinovat, jak takový vodivý spoj vypadá.

\subsubsection{Vodivé spojení bloků}

Prvně bychom měli zadefinovat pojem \textit{vodivý spoj} a~také zmínit jeho vlastnosti. V~naší hře budeme jako \textit{vodivý spoj} chápat propojení bloků skrze netriviální plochu. Tedy dvě stejně velké krychle mohou být vodivě spojeny, pokud mají společný dotyk jejich stěn alespoň o~velikosti stěny jednotkové krychle. Pokud se budou dotýkat hranami, nebo dokonce jen rohy, nebude toto postavení bráno jako vodivý spoj.

Pro implementaci bychom mohli použít (stejně jako u~stavění ve hře \TM{}) systém přípojných bodů. Nicméně to by znamenalo, že bychom museli řešit, jak tento systém upravit pro dynamicky škálovatelné bloky. Navíc, pro nové vizuální reprezentace bloků bychom museli speciálně řešit umístění těchto přípojných bodů, i~vzhledem k~ostatním možným přípojným bloků ve hře). Další zásadní nevýhodou tohoto návrhu je způsob, jak bychom napojovali například krychle o~maximálním a~minimálním rozměru. Abychom mohli využít přípojných bodů, minimální krychle by musela definovat $6$ takových bodů a~maximální krychle pak $2~400$ těchto bodů. S~rostoucí velikostí bloku se počet kontrolovaných přípojných bodů zvětšuje a~obáváme se, že výpočetní algoritmy by mohly být při kontrole velmi pomalé.  Tento postup nám nevyhovuje.



Můžeme však zvolit obdobné řešení -- \uv{\textit{polygonální}}. Pro daný blok definujeme \textit{body}, které se budou v~rámci škálování korektně umisťovat vždy na stejné místo (například roh krychle). Dále pak definujeme \textit{polygony}, což je uspořádaný seznam bodů, které leží v~dané rovině. Tento seznam tvoří virtuální cyklus, takže mezi $k$-tým a~$(k+1)$-tým bodem je \textit{hrana} polygonu. Konceptuální náhled této myšlenky je vidět na obrázku \ref{fig:polygons}.

\begin{figure}[!ht]\centering
\includegraphics[ width=70mm]{../img/analysis/krychle}

\caption{Příklad nastavení polygonů}
\label{fig:polygons}

\end{figure}

\FloatBarrier

Obrázek \ref{fig:polygons} nám dává náhled nějakého možného uspořádání pěti polygonů v~rámci krychle. Silně vykreslené body představují definiční \textit{body}, jednotlivé čáry pak \textit{hrany} polygonů. Záměrně jsme neudělali polygony pravidelné, abychom demonstrovali, že je možné se libovolně přizpůsobovat tvarům vycházejícím z~polygonální reprezentace daného bloku.


V rámci algoritmu spojování bloků skrz vodivé spojení pak budeme hledat pro daný blok sousedy právě dle těchto definic. Budeme počítat s~tím, že polygony jsou v~rámci jedné roviny v~prostoru, přičemž daná rovina je rovnoběžná s~některou z~rovin mřížky herního světa. V~rámci této práce si algoritmus usnadníme takovým způsobem, že jednotlivé studované polygony rozšíříme na \textit{boxy}, tedy najdeme nejmenší možný kvádr, který je zarovnaný do mřížky definované herním světem (tedy nemá vůči ní žádnou rotaci) a~obsahuje všechny body z~daného polygonu\footnote{Abychom mohli použít standardních metod \TT{FBox::Intersect(...)}, musíme \textit{box} rozšířit o~něco netriviálního (např. $1~cm$) ve směru normály dané roviny.}. Za validní a~vodivé elektrické vedení pak budeme považovat takové dva polygony, které mají neprázdný průnik těchto boxů. Jsme si vědomi faktu, že tato úprava jde proti snahám hry o~vyšší stupeň realismu a~pro některé kombinace bloků dokonce bude porušovat naši definici vodivého spojení, ale v~této fázi nám to stačí a~nebudeme vyžadovat matematicky správné řešení.


\subsection{Objekt elektrické sítě}

Spojování bloků do elektrické sítě nevyžaduje žádnou speciální logiku. V~rámci přidávání bloku do herního světa budeme potřebovat vědět o~sousedních blocích (TODO stromy). Pokud bude vazba se sousedním blokem vyhodnocena jako validní vodivý spoj, může se nově připojený blok připojit ke stávající síti, v~níž je i~daný sousední blok.

Pokud budeme vycházet z~premisy, že každý blok je zapojen právě v~jedné elektrické síti a~všechny bloky v~rámci jedné elektrické sítě jsou mezi sebou vodivě spojeny, tak nutně musíme dojít k~závěru, že při manipulaci s blokem budeme muset elektrické sítě aktualizovat. Přidáním bloku jsme bychom mohli vodivě propojit dvě či více sítí, při odebírání se nám daná elektrická síť může rozpadnout na více samostatných komponent. Těchto elektrických sítí může vznikat a~zanikat velké množství. Stačí si uvědomit, že k~bloku \nameref{blocks:A1} o~maximální možné velikosti můžeme připojit až 600 bloků, které budou patřit do stejné sítě (pro každou stěnu máme 100 bloků stejného typu a~minimální velikosti, uspořádaných do šachovnicového vzoru). Pokud pak odebereme centrální blok, může nám vzniknout právě až 600 nových elektrických sítí. Navíc, díky počasí se může stát, že bloky budou odebírány ze světa zcela neuspořádaně (na základě náhodně udělovaného poškození). Musíme tedy vymyslet algoritmus, jak pro všechny bloky v~herním světě udržovat správné informace o~jejich síti.

Protože nemůžeme nic předpokládat o~tom, jak se budou bloky v~elektrické síti chovat, musíme při změně (přidání či odebrání) nějakého bloku v~síti provést přepočítání. Nejjednodušší bude varianta na \textit{algoritmus vlny}. Jednotlivé sítě budeme podle potřeby odstraňovat či slévat. Popišme si nyní pravidla, která budeme muset ve hře mít. Jako sousedy budeme chápat bloky dostupné skrze vodivé spojení.

\subsubsection{Přidávání bloku}
Platí, že každý blok přidaný do herního světa si vytvoří svoji vlastní elektrickou síť.
(TODO kontrola enums níže)
\begin{enumerate}
	\item Pokud blok nemá žádné sousedy, nemusí dělat nic (svoji síť už má)
	\item Pokud mají všichni sousedé stejnou síť, blok se k~ní připojí
	\item Pokud mezi sousedy existují alespoň dvě různé elektrické sítě, blok si vytvoří novou elektrickou síť, propojí ji s~ostatními sítěmi a~vyvolá přepočet sítí
\end{enumerate}

\subsubsection{Odebírání bloku}
Platí, že každý odebíraný blok z~herního světa vždy odstraní síť, ve které je připojen a~pro všechny jeho sousedy jsou vytvořeny nové sítě.

\begin{enumerate}
	\item Pokud blok nemá žádné sousedy, svoji síť ze hry odstraní a~dále nedělá nic
	\item Pokud má blok právě jednoho souseda, odpojí od se od dané sítě
	\item Pokud má alespoň dva sousedy, pro každého vytvoří novou síť a~vyvolá přepočet sítí
\end{enumerate}

\subsection{Udržování konzistence elektrických sítí}

Jak je vidět z~předchozí kapitoly, objektů k~aktualizaci může být velmi mnoho. Nesmíme však dopustit, aby se nám při přepočítávání začala hra zpomalovat či přímo zasekávat\footnote{Tato situace může snadno nastat, protože herní a~renderovací smyčky se na konci svých cyklů synchronizují, aby pro výpočet dalšího framu začínaly stejně.}. Opět máme více možností řešení, jak se k~tomuto problému postavit. 

Jedním z~možných řešení je spuštění výpočtů na samostatném výpočetním vlákně. Zde bohužel narážíme na problém, že výpočty ve vláknech v~\UEu{} nemohou přímo přistupovat k~herním objektům a~tudíž je nutné používat pomocných datových struktur a~výsledky poté zpětně propagovat. Kromě toho také narážíme na problém, kdy v~případě velmi silné bouře kyselých dešťů bude nejspíše často nutné výpočet předčasně ukončit a~spustit znovu.

My navrhujeme následující algoritmus, využívající front požadavků ke zpracování a~omezení výpočetního času. Ještě musíme zmínit, že také využívá toho, že jak elektrická síť, tak každý blok v~ní si nese informaci o~stavu. Ty jsou tři:
\begin{itemize}
	\item Nevalidní
	\item Ve výpočtu
	\item Validní
\end{itemize}
Volba stavů je zřejmá a~vychází z~principů algoritmu vlny. Dalším netriviálním faktem je, že v~algoritmu existuje fronta sítí k~přepočítání, přičemž každá taková má svoji frontu bloků v~síti k~přepočítání. Hlavním krokem algoritmu je pak výběr sítě k~přepočítání a~provedení jednoho kroku přepočtu. Následně, pokud má tato síť stále nějaké bloky k~přepočtu, je zařazena na konec přepočítávací fronty a~tam čeká, dokud nebude opět vyzvednuta. Může se však stát, že jistou posloupností kroků při mazání bude tato síť označena jako nevalidní a~dále se přepočítávat nebude.

Algoritmus bude mít přidělené nějaké maximální kvantum času, řekněme tak, aby při jeho výpočtech hra dosahovala alespoň 30 snímků za sekundu. Tím vcelku jednoduchým a~elegantním způsobem zajistíme přepočty i~pro velice rozsáhlé sítě. Samozřejmě je nutné, aby hra počítala s~tím, že elektrická síť a~bloky v~ní mohou být ve stavu \textit{ve výpočtu} a~tomu přizpůsobovat další funkcionalitu (například nevyužívat zdrojů takovéto sítě, dokud blok není \textit{validní} -- pak je možné využívat pouze dalších validních bloků, tedy těch, které již byly zpracovány algoritmem).

TODO tabulka případů, říct, že tohle bude komponenta

\subsection{Interakce a~označování}
\label{subsec:interaction}

Dalším problémem je interakce s~uživatelem. Abychom věděli, že hráč s~daným blokem chce interagovat, musíme vědět, že:
\begin{itemize}
	\item Je dostatečně blízko bloku
	\item Z~pohledu hráče se dívá na daný blok 
	\item Vyjadřuje fakt, že chce interagovat (např. stiskem klávesy)
\end{itemize}



Nejsnazší způsob, jak zjistit, na jaký herní objekt se hráč dívá, je použití techniky sledování paprsku (\textit{ray tracing}). Díky němu můžeme \uv{z kamery} vyslat virtuální paprsek, který má stejný směr, jako je směr pohledu kamery. Pokud bude hráčův \HUD{} zobrazovat zaměřovací kříž (či použijeme nějaký obdobný mechanismus) a~náš paprsek bude z~pohledu kamery tímto zaměřovačem procházet, hráč může cíleně mířit na herní objekty a~my zároveň budeme mít správnou informaci o~objektu, na který hráč zaměřovačem míří. Tento způsob získávání informace o~objektech v~hráčově zaměřovači je ve hrách běžný a~jeho použití je (pokud je vhodně použito) i~dostatečně rychlé.

Nyní, když už víme, jak můžeme získávat informace o~tom, na který objekt hráč míří, tak tento mechanismus ještě rozšíříme o~další vlastnost. Je zapotřebí si uvědomit, že interakce s~blokem a~umisťování nového herního bloku (případně mazání) jsou prakticky stejné akce. Liší se pouze výsledkem -- reakcí na stisk nějaké klávesy či tlačítka myši. Ale ve všech případech musíme vědět, na jaký blok hráč míří zaměřovačem, u~umisťování navíc potřebujeme znát i~přesný polygon, na který hráč míří. Konkrétní polygon potřebujeme znát z~toho důvodu, že chceme, aby se přidávaný blok \uv{přilepil} k~bloku, na který míříme. Tedy chceme zachovat herní mechaniku, která je v~hrách z~kapitoly \ref{chap:uvod} běžná a~je natolik intuitivní a~rozšířená, že změna této mechaniky by nejspíše nedopadla dobře a~hráči by nebyla kladně přijata.

Pro implementaci nám poslouží metoda \TT{LineTraceSingleByObjectType},\linebreak které předáme správné parametry (především počátek a~konec paprsku a~typy objektů, které paprsek zaznamená) a~ta nám vrátí strukturu, popisující výsledek trasování. Z~něj se můžeme dozvědět, jestli byl nějaký blok v~cestě paprsku. A~pokud ano, můžeme se ptát, zda měl komponentu interakce (potenciálně bychom mohli chtít bloky bez možnosti zaměření a~interakce, jakožto nesmazatelné objekty). Pokud bude i~tato podmínka splněna, můžeme se zajímat o~další vlastnosti kolize paprsku s~blokem a~na základě toho se nějak chovat.

Abychom hráči hraní usnadnili a~zpříjemnili, budeme bloky zvýrazňovat za použití techniky \textit{obrysu} (implementace zvýrazňování bude vycházet z~tutorialu~\citep{ue_outline_tut}). Tato technika je také využívána v~různých hrách napříč různými herními žánry a~proto její implementací nic nezkazíme. Obrys zobrazíme v~případě, kdy hráč nic nestaví a~daný označený blok je použitelný (takže hráč ví, že blok může používat), nebo v~případě, kdy hráč staví (zvýrazníme hranice namířeného objektu). Barvu obrysu můžeme zvolit kupříkladu zelenou pro použitelný blok, žlutou při stavění a~červenou při odebírání bloku. 


\subsection{Umístění ve světě}

Smyslem této komponenty je oddělení implementace bloku jako takového a~implementace herního světa. Skrze tuto komponentu se blok bude moci dotazovat na ostatní bloky v~herním světě, především pak bloky ve svém okolí. To bude důležité například pro elektrickou komponentu, která na základě \uv{sousedství} bude jednotlivé bloky vázat k~sobě do elektrické sítě.






