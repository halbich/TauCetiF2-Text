%!TEX root = ../../prace.tex

\section{Struktura projektu}

Strukturu přhodit do analýzy

Celý projekt je rozdělen do dvou částí -- \CPP{} část a~Blueprintová část. \UE{} umožňuje herním vývojářům implementovat celou hru kompletně za pomocí Blueprintů, tedy vizuálního rozhraní. Toho se však obvykle nevyužívá, protože vykonávání programu v~Blueprintu je přibližně 10 krát pomalejší, než vykonávání nativního \CPP{} kódu (TODO link). V praxi tak dochází k~tomu, že vývojář (i neprogramátor) může za pomocí Blueprintů rychle prototypovat funkcionalitu, kterou pak kodér přepíše do metod v~\CPP{}, správně tyto metody označí makry tak, aby \UE{} tyto metody v~kódu našel (což se provádí za pomocí reflexe v~\UBT{} a~použitím příslušných \CPP{} maker) a~upraví Blueprint tak, aby původní kód tyto metody volal.

 V Blueprintu je kód vizualizován jako graf uzlů a~jsou zde zaznamenány vztahy mezi těmito uzly. Uzly tedy odpovídají funkcím v~\CPP{} a~těm je pak možné předávat parametry ať už v~podobě proměnných definovaných v~\CPP{} kódu nějaké třídy, nebo proměnných definovaných přímo v~Blueprintu. Vztahy mezi uzly pak označují následující kód určený k~vykonávání. Můžeme také říct, že vykonávání kódu v~Blueprintu je \textit{interpretované}, z~čehož vyplývá absence případných kompilačních optimalizací. Ergo slabý výkon. 

Některé části programu jsou implementovány na úrovni \CPP{}, jiné bylo nutné implementovat v~Blueprintech. Už víme, že komunikace z~Blueprintu do \CPP{} je možná prostým voláním metod, ale určitě budeme potřebovat i~možnost opačného směru. Toho je možné dosáhnout více způsoby -- kupříkladu použitím delegátů a~událostí (Blueprint se pak na tuto událost naváže a~v~případě vyvolání dané události vyvolá v~Blueprintu definovanou obsluhu), nebo BlueprintImplementable či BlueprintNative metod. (TODO formátování!, link na Specifikaci?) Poslední dvě nám nabízí možnost, jak volat virtuální metody, které je možné přepisovat jak na straně \CPP{}, tak na straně Blueprintu, což se nám bude hodit.

V dalším textu tedy postupně probereme prvně kódovou část napsanou v~\CPP{} a~poté strukturu projektu s~samotném \UE{}. Ještě bychom zde měli zmínit, že ačkoliv se v~textu budeme odkazovat převážně na hlavičkové soubory, stále budeme brát v~potaz i~implementační, tedy \TT{.cpp} soubory a~obsah textu se může na tuto implementaci odkazovat.


